# Parser for Piga's own syntax.
#
# Piga is a Parsing Expression Grammar (PEG) parser generator.
#
# == lexing
#
# A lexer is required (for now). Tokens are represented as UPPERCASE.
#
# == directives
#
# Directives supply configuration options.
#
# A directive name starts with a `%`, and is followed by one of more words.
#
# - `%name` - set the generated parser's class name
#
# == rules
#
# Rules are defined in a similar syntax to yacc/bison, but the `|` represents
# ordered choice.
#
# == usage
#
#     $ bundle exec exe/piga lib/piga/piga.piga > lib/piga/parser.rb
#     $ bundle exec ruby lib/piga/parser.rb

%name Piga::Grammar::Parser;

grammar
  : sp* directives sp* rules { s(:grammar, val[1], val[3]) }
  | sp* directive sp* rules { s(:grammar, val[1], val[3]) }
  | sp* rules { s(:grammar, [], val[3]) }
  ;
directives
  : directive sp* directives { s(:directives, val[0], *val[2]) }
  | directive  { s(:directives, val[0]) }
  ;
directive
  : _directive sp* names sp* ";"* { s(:directive, val[0], *val[2]) }
  | _directive name sp* name sp* ";"*  { s(:directive, val[0], val[1], val[3]) }
  # : "%" name sp* names sp* ";"* { s(:directive, val[1], *val[3].flatten) }
  # | "%" name sp* name sp* ";"*  { s(:directive, val[1], val[3]) }
  ;
names
  : name sp* names { [val[0], *val[2..-1]] }
  | name           { [val[0]] }
  ;
rules
  : rule sp* rules { s(:rules, val[0], *val[2]) }
  | rule           { s(:rules, val[0]) }
  ;
rule
  : name sp* ":" sp* alternatives sp* ";" { s(:rule, val[0], val[4]) }
  ;
alternatives
  : alternative sp* "|" sp* alternatives  { s(:alternatives, val[0], *val[4]) }
  | alternative                           { s(:alternatives, val[0]) }
  ;
alternative
  : sp* alt sp* block { s(:alt, s(:items, *val[1]), s(:action, val[3])) }
  | sp* alt sp*       { s(:alt, s(:items, *val[1]), s(:action, "val[0]")) }
  ;
alt: items;
items
  : item sp* items* { [val[0], *val[2..-1]].flatten }
  ;
item
  : name '*' { s(:zero_or_more, s(:name, val[0])) }
  | name '+' { s(:one_or_more, s(:name, val[0])) }
  | name     { s(:name, val[0]) }
  | literal '*' { s(:zero_or_more, s(:literal, val[0])) }
  | literal '+' { s(:one_or_more, s(:literal, val[0])) }
  | literal     { s(:literal, val[0]) }
  ;
sps: sp* { val };
sp: '\n' | " " | comment;
